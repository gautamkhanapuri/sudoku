<!DOCTYPE html>
<html lang="en">
	<head>
		<meta name="description" content="Sudoku Puzzles">
		<meta name="author" content="GAK">
		<meta name="github" content="GAK">
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Sudoku Puzzles</title>
		<style>

			.canvas-container {
				display: none; /* This will now transition smoothly */
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				overflow: hidden;
				opacity: 1;
				scale: 1;
				outline: none;
				transition: opacity 0.5s ease, scale 0.5s ease, width 0.5s ease;
				transition-behavior: allow-discrete; /* Important for display transition */
			}
			.canvas-container.hidden { /* State when hidden */
				display: none; /* For smooth transition */
				opacity: 0;
				scale: 0;
			}

			.circles li span {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%); /* Centers the span both horizontally and vertically */
			}
			.area{
				background: #4e54c8;  
				background: -webkit-linear-gradient(to left, #8f94fb, #4e54c8);  
				width: 100%;
				height:100vh;
			}
			.circles{
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				overflow: hidden;
				pointer-events: none;
			}
			.circles li{
				position: absolute;
				display: block;
				list-style: none;
				width: 20px;
				height: 20px;
				background: rgba(205, 205, 155, 0.2);
				animation: animate 25s linear infinite;
				bottom: -150px;
				text-align: center;
				font-size: 40px;
				font-weight: bold;
				color: white;
				pointer-events: none;
			}
			.circles li:nth-child(1){
				left: 25%;
				width: 50px;
				height: 50px;
				animation-delay: 4s;
			}
			.circles li:nth-child(2){
				left: 15%;
				width: 55px;
				height: 55px;
				animation-delay: 2s;
				animation-duration: 12s;
			}
			.circles li:nth-child(3){
				left: 70%;
				width: 60px;
				height: 60px;
				animation-delay: 4s;
			}
			.circles li:nth-child(4){
				left: 80%;
				width: 65px;
				height: 65px;
				animation-delay: 3s;
				animation-duration: 18s;
			}
			.circles li:nth-child(5){
				left: 65%;
				width: 70px;
				height: 70px;
				animation-delay: 1s;
			}
			.circles li:nth-child(6){
				left: 75%;
				width: 75px;
				height: 75px;
				animation-delay: 3s;
			}
			circles li:nth-child(7){
				left: 30%;
				width: 70px;
				height: 70px;
				animation-delay: 7s;
			}
			.circles li:nth-child(8){
				left: 20%;
				width: 65px;
				height: 65px;
				animation-delay: 5s;
				animation-duration: 25s;
			}
			.circles li:nth-child(9){
				left: 10%;
				width: 60px;
				height: 60px;
				animation-delay: 2s;
				animation-duration: 15s;
			}
			@keyframes animate {
				0%{
					transform: translateY(0) rotate(0deg);
					opacity: 1;
					border-radius: 0;
				}
				100%{
					transform: translateY(-1000px) rotate(720deg);
					opacity: 0;
					border-radius: 50%;
				}
			}

			.greyed-out {
				background-color: grey; /* Or a specific grey color like #ccc */
				/*opacity: 0.6;*/ /* Reduce opacity for a faded look */
				pointer-events: none; /* Disable click events */
			}

			.tooltip {
				position: absolute;
				visibility: hidden;
				background-color: #333;
				color: #fff;
				padding: 5px 10px;
				border-radius: 4px;
				font-size: 14px;
				z-index: 1000;
				opacity: 0;
				transition: opacity 0.3s ease-in-out;
			}
			.tooltip.show {
				visibility: visible;
				opacity: 1;
			}

			* {
				font-family: "Roboto", sans-serif;
				text-align: center;
			}
			.table {
				margin-top: 2vh;
				display: grid;
				grid-template-columns: 162px 162px 162px;
				grid-template-rows: 162px 162px 162px;
				justify-content: center;
				align-content: center;
			}
			.groups {
				display: grid;
				grid-template-columns: 53px 53px 53px;
				grid-template-rows: 53px 53px 53px;
				border: solid 2px black;
			}
			.elem {
				border: solid 1px black;
				font-size: 30px;
			}
			.common {
				display: flex;
				justify-content: center;
				column-gap: 20px;
			}
			.btn {
				margin-top: 1vh;
				width: 150px;
				height: 30px;
				justify-content: center;
				padding-top: 10px;
				background-color: #007bff;
				color: white;
				font-size: large;
				font-weight: bold;
				border-radius: 10%;
				transition: all 0.5s ease-out;
			}
			.btn:hover {
				scale: 1.2;
				transition-delay: 0.01s;
			}
			.btn:active {
				scale: 0.9;
			}
			.mainheading {
				margin-top: 3vh;
				margin-bottom: 1vh;
				font-size: 20px;
				font-weight: bold;
				color: white;
			}
			#outputshow {
				margin: 1vh;
				font-size: 15px;
				font-weight: bold;
				color: white;
			}
			.input-container-puzzle {
				width: 50vw; /* 50% of viewport width */
				margin: 0 auto; /* Centers the div horizontally */
				display: flex; /* Enables flexbox for aligning input and button */
				justify-content: center; /* Centers items horizontally within the flex container */
				align-items: center; /* Centers items vertically within the flex container */
				gap: 5px;
			}
			.input-container-outside {
				width: 50vw; /* 50% of viewport width */
				margin: 0 auto; /* Centers the div horizontally */
				display: flex; /* Enables flexbox for aligning input and button */
				justify-content: center; /* Centers items horizontally within the flex container */
				align-items: center; /* Centers items vertically within the flex container */
				gap: 20px;
			}
			.input-container {
				margin-top: 1vh;
				display: flex; /* Enables flexbox for aligning input and button */
				justify-content: center; /* Centers items horizontally within the flex container */
				align-items: center; /* Centers items vertically within the flex container */
				gap: 5px;
			}
			#inpuzzle {
				flex-grow: 1; /* Allows the input to grow and fill available space */
				width: 45vw; /* Sets the input field to 45% of the viewport width */
				padding: 10px;
				border: solid 2px black;
				box-sizing: border-box;
				font-size: 15px;
			}
			#guessClear,
			#loadButton,
			#clearButton {
				padding: 10px 15px;
				background-color: #007bff;
				color: white;
				border: none;
				cursor: pointer;
				font-size: 15px;
				font-weight: bold;
			}
			.hint,
			.guess {
				margin: 1vh;
				color: white;
				font-size: 15px;
				font-weight: bold;
			}
		</style>
	</head>
	<body class="area">
		<canvas class="canvas-container"></canvas>
		<div>
			<ul class="circles">
				<li><span>1</span></li>
				<li><span>2</span></li>
				<li><span>3</span></li>
				<li><span>4</span></li>
				<li><span>5</span></li>
				<li><span>6</span></li>
				<li><span>7</span></li>
				<li><span>8</span></li>
				<li><span>9</span></li>
			</ul>
		</div >
		<p class="mainheading">Suduko Puzzles</p>
		<div class="input-container-puzzle">
			<input type="text" id="inpuzzle" placeholder="Sudoku as 012000034100...">
			<button id="loadButton" onclick="handleLoad()">Load</button>
			<button id="clearButton" onclick="clearInput()">Clear</button>
		</div>
		<div class="input-container-outside">
		<div class="input-container">
			<span class="guess"><u>Guess:</u></span>
			<label class="guess"><input type="radio" name="guess" value="true">Enable</label>
			<label class="guess"><input type="radio" name="guess" value="false" checked>Disable</label>
			<button id="guessClear">Clear</button>
		</div>
		<div class="input-container">
			<span class="guess"><u>Hint:</u></span>
			<label class="hint"><input type="radio" name="hint" value="true" checked>Enable</label>
			<label class="hint"><input type="radio" name="hint" value="false">Disable</label>
		</div>
		<div class="input-container">
			<span class="guess"><u>Difficulty:</u></span>
			<input type="number" id="hintcount" min="4" max="52" value="45">
		</div>
		</div>
		<p id="outputshow">New Puzzle</p>
		<div id="tbl" class="table"></div>
		<div class="common">
			<div class="btn" onclick="reader()">Solve</div>
			<div class="btn" onclick="reset()">Reset</div>
			<div class="btn" onclick="generateNew()">New</div>
		</div>
	</body>
	<script>

		class Spinner {
			static gravity = 0.006;
			static friction = 1;
			constructor(x, y, radius, color, velocity) {
				this.x = x;
				this.y = y;
				this.radius = radius;
				this.color = color;
				this.velocity = velocity;
				this.alpha = 1 // alpha = opacity;
			}
			draw() {
				canvasContext.save();
				canvasContext.globalAlpha = this.alpha;
				canvasContext.beginPath();
				canvasContext.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
				canvasContext.fillStyle = this.color;
				canvasContext.fill();
				canvasContext.closePath();
				canvasContext.restore();
			}
			update() {
				this.draw();
				this.velocity.x *= Spinner.friction;
				this.velocity.x *= Spinner.friction;
				this.velocity.y += Spinner.gravity;
				this.x += this.velocity.x;
				this.y += this.velocity.y;
			}
		}

		function puzzleOverInit() {
			spinners = [];
		}

		function puzzleOverAnimate() {
			animationId = requestAnimationFrame(puzzleOverAnimate);
			canvasContext.fillStyle = '#4e54c8';
			// canvasContext.fillStyle = 'rgba(0, 0, 0, .15)';
			canvasContext.fillRect(0, 0, canvas.width, canvas.height);
			spinners.forEach((spinner) => {
				if (spinner.alpha > 0)
					spinner.update();
				else
					spinner.splice(i, 1);
			});
		}

		function puzzleOverStartAnimate() {
			canvas = document.querySelector('canvas');
			canvas.style.display = 'block';
			canvas.classList.remove('hidden');
			canvasContext = canvas.getContext('2d'); // context within canvas
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			canvas.setAttribute('tabindex', '0'); // Make it focusable for keypress
			canvas.focus(); // Set focus
			puzzleOverInit();
			handleMouseoutEvent();
			puzzleOverAnimate();
			const particleCount = 400;
			const angleIncrement = (Math.PI * 2) / particleCount;
			for (let i = 0; i < particleCount; i++) {
				spinners.push(
					new Spinner(canvas.width/2, canvas.height/2, 5,
						`hsl(${Math.random() * 360}, 50%, 50%)`, {
							x: Math.cos(angleIncrement * i) * (Math.random() * 10),
							y: Math.sin(angleIncrement * i) * (Math.random() * 10)
						}
					));
			}
			canvas.addEventListener('keypress', (ev) => { puzzleOverStopAnimate(ev); });
			canvas.addEventListener('click', (ev) => { puzzleOverStopAnimate(ev); });
			canvas.addEventListener('resize', () => {
				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;
            puzzleOverInit();
			});
		}

		function puzzleOverStopAnimate(ev) {
			cancelAnimationFrame(animationId);
			canvas.classList.add('hidden');
			setTimeout(() => {
				canvas = null;
				canvasContext = null;
				spinners = null;
				animationId = null;
			}, 1000);
		}

		function clearInput() {
			const input = document.getElementById('inpuzzle');
			input.value = "";
		}

		function generateNew() {
			resetBoard();
			let res = solve();
			let puzzle = generate(res.result, hintCount);
			// console.log("Generated: " + puzzle);
			generateBoard(puzzle);
			document.getElementById("outputshow").innerText = "New Puzzle";
			document.getElementById('inpuzzle').value = puzzle;
			const radioButtons = document.getElementsByName("guess");
			for (let i = 0; i < radioButtons.length; i++) {
				if (radioButtons[i].value === "false") {
					radioButtons[i].checked = true;
					break; // Stop after finding and checking the desired radio button
				}
			}
			let btn = document.getElementById('guessClear')
			btn.style.backgroundColor = 'grey';
			btn.classList.add('greyed-out');
			guess = 0;
			guessList.clear();
		}

		function reset() {
			for (let i = 0; i < 9; i++) {
				for (let j = 0; j < 9; j++) {
					board[i][j]=0;
				}
			}
			for (let i = 1; i < cnt; i++) {
				let objid = "at" + i;
				let obj = document.getElementById(objid);
				obj.value = "";
				obj.readOnly = false;
				obj.style.color = 'black';
				board[obj.dataset.row][obj.dataset.col] = 0;
			}
			document.getElementById("outputshow").innerText = "Start a New Puzzle";
			solvedCnt = 0;
		}

		function handleLoad() {
			const input = document.getElementById('inpuzzle');
			let vals = input.value.split("");
			if (vals.length != (cnt-1))
				alert('Length should be 81 chars: ' + input.value);
			else {
				generateBoard(input.value);
				document.getElementById("outputshow").innerText = "New Puzzle";
			}
		}

		function generateBoard(input) {
			solvedCnt = 0;
			let vals = input.split("");
			let numericReg = /^[1-9]$/;
			for (let i = 1; i < cnt; i++) {
				let objid = "at" + i;
				let obj = document.getElementById(objid);
				let idx = parseInt(obj.dataset.row) * 9 + parseInt(obj.dataset.col);
				if (numericReg.test(vals[idx])){
					obj.value = vals[idx];
					obj.readOnly = true;
					obj.style.color = 'blue';
					board[obj.dataset.row][obj.dataset.col] = vals[idx];
					solvedCnt += 1;
				} else {
					obj.value = "";
					obj.readOnly = false;
					obj.style.color = 'black';
					board[obj.dataset.row][obj.dataset.col] = 0;
				}
			}
		}

		function createBoard() {
			const boardTbl = document.getElementById('tbl');
			for(let grp=0; grp<9; grp++){
				const cell = document.createElement('div');
				cell.className = "groups";
				let rowMultiplier = Math.floor(grp/3);
				let colMultiplier = grp % 3;
				let rowStart = 0 + rowMultiplier*3;
				let rowEnd = 3 + rowMultiplier*3;
				for(let row=rowStart; row<rowEnd; row++){
					let colStart = 0 + colMultiplier*3;
					let colEnd = 3 + colMultiplier*3;
					for(let col=colStart; col<colEnd; col++){
						const newCell = document.createElement('input');
						newCell.className="elem"
						newCell.id="at" + cnt;
						cnt += 1;
						newCell.dataset.row = row;
						newCell.dataset.col = col;
						newCell.autocomplete="off";
						if (grp % 2 == 0)
							//newCell.style.backgroundColor = "antiquewhite";
							newCell.style.backgroundColor = "lightblue";
						newCell.setAttribute('type', 'text');
						newCell.setAttribute('pattern', '[0-9]*');
						newCell.setAttribute('inputmode', 'numeric');
						newCell.setAttribute('maxlength', "1");
						cell.appendChild(newCell);
					}
				}
				boardTbl.appendChild(cell);
			}
			// console.log("Count ==> " + cnt);
		}

		function reader() {
			for (let i = 1; i < cnt; i++) {
				let objid = "at" + i;
				let obj = document.getElementById(objid);
				if (obj.value != "")
					board[obj.dataset.row][obj.dataset.col] = obj.value;
				else
					board[obj.dataset.row][obj.dataset.col] = 0;
			}
			let newprom = new Promise((resolve, reject) => {
				let ans = solveNow();
				if (ans) {
					resolve();
				} else {
					console.log("Error in the solution");
					reject();
				}
			});
			newprom.then(() => {
				afterSolve();
				linePrinter(true);
			}).catch(() => {
				console.log("Error in the solution");
				linePrinter(false);
			});
		}

		function linePrinter(argument) {
			if (argument) {
				document.getElementById("outputshow").innerText = "Puzzle solved successfully.";
				// document.getElementById("outputshow").style.color = "Black";
			} else {
				document.getElementById("outputshow").innerText = "Error: Recheck the values";
				document.getElementById("outputshow").style.color = "Red";
			}
		}

		function solveNow() {
			for (let i = 0; i < 9; i++) {
				for (let j = 0; j < 9; j++) {
					if (board[i][j] == 0) {
						for (let val = 1; val <= 9; val++) {
							if(checker(i,j,val)){
								board[i][j]=val;
								let nextsol=solveNow();
								if(!nextsol){
									board[i][j]=0;
								} else{
									return true;
								}
							}
						}
						return false;
					}
				}
			}
			return true;
		}

		function checker(row, col, val) {
			for (let i = 0; i < 9; i++) {
				if (board[row][i] == val)
					return false;
				if (board[i][col] == val)
					return false;
				irow = 3 * Math.floor(row / 3) + Math.floor(i / 3);
				icol = 3 * Math.floor(col / 3) + (i % 3);
				if (board[irow][icol] == val)
					return false;
			}
			return true;
		}

		function afterSolve() {
			for (let i = 1; i < cnt; i++) {
				let objid = "at" + i;
				let obj = document.getElementById(objid);
				obj.value = board[obj.dataset.row][obj.dataset.col];
			}
			solvedCnt = cnt-1;
			guess = 0;
			guessList.clear();
			const cells = document.querySelectorAll('input.elem');
			cells.forEach(cell => {
				cell.readOnly = true;
			});
		}

		function boardState(){
			let fnl = '';
			for (let i = 0; i < 9; i++) {
				fnl = fnl + board[i].join("");
			} 
			return fnl;
		} 

		function sumLetters(str) {
			let sum = 0;
			let splitStr = str.split('');
			for (let i = 0; i < splitStr.length; i++) {
				sum += parseInt(splitStr[i])
			}
			return sum;
		}

		function randPerm(n) {
			const arr = Array.from({length: n}, (_, i) => i+1); // array from 1 to n
			for (let i = n - 1; i > 0; i--) { // Shuffle the array
				const j = Math.floor(Math.random() * (i + 1));
				[arr[i], arr[j]] = [arr[j], arr[i]]; //Swap
			}
			return arr;
		}

		function solve() {
			for (let i = 0; i < 9; i++) {
				for (let j = 0; j < 9; j++) {
					if (board[i][j] == 0) {
						let arr = randPerm(9)
						for (let k=0; k<arr.length; k++) {
							let val = arr[k];
							if(checker(i,j,val)){
								board[i][j] = val;
								let nextsol = solve();
								if(!nextsol.status){
									board[i][j]=0;
								} else{
									return nextsol;
								}
							}
						}
						return {status: false, result: ''};
					}
				}
			}
			let stateStr = boardState();
			let total = sumLetters(stateStr);
			let mystatus = false;
			if (total == 405)
				mystatus = true;
			return {status: mystatus, result: stateStr};
		}

		function resetBoard() {
			for (let i = 0; i < 9; i++) {
				for(let j=0; j<9; j++){
					board[i][j] = 0;
				}
			}
		}

		function loadBoard(s) {
			let vals = s.split("");
			let count = 0;
			for (let i = 0; i < 9; i++) {
				for (let j = 0; j < 9; j++) {
					board[i][j] = vals[count];
					count += 1;
				}
			}
		}

		function generate(soln, hintCnt) {
			const arr = randPerm(81);
			let idx = 0;
			let count = 0;
			let currSoln = soln;
			let savedSoln = '';
			while( idx < 81) {
				let pos = arr[idx] - 1;
				i = Math.floor(pos/9);
				j = pos % 9;
				resetBoard();
				loadBoard(currSoln);
				savedDigit = board[i][j];
				board[i][j] = 0;
				savedSoln = boardState();
				val = solve();
				if (val.status) {
					let newSoln = boardState();
					if (newSoln == soln) {
						// console.log("Multiple solutions: " + newSoln);
						count += 1;
						currSoln = savedSoln;
					} else {
						board[i][j] = savedDigit;
					}
				} else {
					board[i][j] = savedDigit;
				}
				if (count == hintCnt)
					break;
				idx += 1;
			}
			// console.log("Count: " + count + ", hintCount: " + hintCnt);
			return currSoln;
		}

		function handleInputEvent(event) {
			if (event.target.readOnly)
				return;
			// Handle Backspace, delete or Ctrl-Z where event.target.value will be ""
			let value = event.target.value;
			if (value == "") {
				// Check if the previous value was value 1-9
				if (board[event.target.dataset.row][event.target.dataset.col] != 0){
					board[event.target.dataset.row][event.target.dataset.col] = 0;
					solvedCnt -= 1; // handle solvedCnt
					if (guess == 1) { // guessList  may need to be updated.
						let gList = guessList.get('' + guess);
						let indexToRemove = gList.indexOf(event.target.id);
						if (indexToRemove != -1) 
							gList.splice(indexToRemove, 1); // Removes 1 element at index
					}
				}
			} else {
				event.target.value = event.target.value.replace(/[^1-9]/g, '');
				if (event.target.value != "") {
					if(checker(event.target.dataset.row, event.target.dataset.col, event.target.value)){
						if (guess == 1) {
							// aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive,
							// purple, red, silver, teal, white, and yellow
							event.target.style.color = 'fuchsia';
							guessList.get('' + guess).push(event.target.id);
						} else {
							event.target.style.color = 'green';
						}
					} else {
						event.target.style.color = 'red';
					}
					// Could be Ctrl-Z presses had previous values, increment if previous value was 0
					if (board[event.target.dataset.row][event.target.dataset.col] == 0)
						solvedCnt += 1;
					board[event.target.dataset.row][event.target.dataset.col] = event.target.value;
					if ( solvedCnt == (cnt-1)) {
						let result = solve();
						if (result.status) {
							guess = 0;
							guessList.clear();
							const cells = document.querySelectorAll('input.elem');
							cells.forEach(cell => {cell.readOnly = true;});
							linePrinter(true);
							puzzleOverStartAnimate();
						} else {
							linePrinter(false);
						}
					}
				} else {
					event.target.style.color = 'black';
					board[event.target.dataset.row][event.target.dataset.col] = 0;
				}
			}
			// console.log("Solved: " + solvedCnt);
		}

		function clearGuess(e) {
			console.log("Clear Guesses...");
			guessList.forEach((gList, gId) => {
				for(let i=0; i<gList.length; i++) {
					let objId = document.getElementById(gList[i]);
					objId.value = ""
					board[objId.dataset.row][objId.dataset.col] = 0;
					solvedCnt -= 1;
				}
				gList.splice(0, gList.length);
			});
		}

		function handleMouseoutEvent() {
			if (!showHint)
				return;
			if (currentTooltip) {
				currentTooltip.classList.remove('show');
				if (currentTooltip && currentTooltip.parentNode) {
					currentTooltip.remove();
					currentTooltip = null;
				}
			}
		}

		function handleMouseOverEvent(event) {
			if (!showHint)
				return;
			if (currentTooltip) { // Remove any existing tooltip
				currentTooltip.remove();
			}
			if (board[event.target.dataset.row][event.target.dataset.col] != 0)
				return;
			let element = event.target;
			let txt = '';
			for(let i=1; i<10; i++){
				if(checker(event.target.dataset.row, event.target.dataset.col, i)) {
					if (txt != "")
						txt = txt + "," + i;
					else
						txt = txt + i;
				}
			}
			const tooltipText = txt;
			if (!tooltipText)
				return;
			currentTooltip = document.createElement('div');
			currentTooltip.classList.add('tooltip');
			currentTooltip.textContent = tooltipText;
			document.body.appendChild(currentTooltip);
			const rect = element.getBoundingClientRect();
			currentTooltip.style.left = `${rect.left + window.scrollX}px`;
			currentTooltip.style.top = `${rect.top + window.scrollY - currentTooltip.offsetHeight - 10}px`;
			currentTooltip.classList.add('show');
		}

		function mainInit() {
			createBoard();
			const cells = document.querySelectorAll('input.elem');
			cells.forEach(cell => {
				cell.addEventListener('input', handleInputEvent);
				cell.addEventListener('mouseover', handleMouseOverEvent);
				cell.addEventListener('mouseout', handleMouseoutEvent);
			});
			generateNew();

			const guessRadios = document.querySelectorAll('input[name="guess"]');
			guessRadios.forEach(radio => {
				radio.addEventListener('change', function() {
					let currentGuess = (this.value == "true") ? 1 : 0;
					const button = document.getElementById('guessClear');
					if (currentGuess) {
						button.disabled = false;
						button.classList.remove('greyed-out');
						button.style.backgroundColor = '#007bff';
						guessList.set('' + currentGuess, new Array());
						button.addEventListener('click', clearGuess);
					} else {
						button.removeEventListener('click', clearGuess);
						button.disabled = true;
						guessList.delete('' + currentGuess);
						button.classList.add('greyed-out');
						button.style.backgroundColor = 'grey';
					}
					guess = currentGuess;
				});
			});
			let btn = document.getElementById('guessClear')
			btn.style.backgroundColor = 'grey';
			btn.classList.add('greyed-out');
			const hintRadios = document.querySelectorAll('input[name="hint"]');
			hintRadios.forEach(radio => {
				radio.addEventListener('change', function() {
					showHint = (this.value == "true") ? true : false;
				});
			});
			document.getElementById('hintcount').addEventListener('change', function() {
				hintCount = parseInt(this.value);
			});
			document.getElementById('hintcount').value = hintCount;
		}

		let cnt = 1;
		let solvedCnt = 0;
		let hintCount = 52;
		let guess = 0;
		let showHint = true;
		const guessList = new Map();
		let currentTooltip = null;
		let board = new Array(9);
		for (let i = 0; i < 9; i++) {
			board[i] = new Array(9);
		}
		// declare canvas animate variables
		let canvas;
		let canvasContext;
		let animationId;
		let spinners;
		mainInit();
  </script>
</html>
